import { app, BrowserWindow, ipcMain } from 'electron';
import startDiscovery from 'multicast-dns';
import { IPC_MESSAGES } from './shared';
import ip from 'ip';
import {
  FrontEndHost,
  frontEndHostUrl,
} from '@openmsupply-client/common/src/hooks/useElectronClient';
import storage from 'electron-data-storage';

const SERVICE_NAME = '_omsupply._tcp.local';
const SERVICE_TYPE = 'TXT';
const QUERY_INTERVAL = 1000;

const discovery = startDiscovery();

let connectedServer: FrontEndHost | null = null;
let isDiscovering = false;

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const connectToServer = (window: BrowserWindow, server: FrontEndHost) => {
  isDiscovering = false;
  const url = frontEndHostUrl(server);
  // Can change 'frontEndHostUrl(server)' to http://localhost:3003 if you want client to display front end served by webpack
  window.loadURL(url);
  connectedServer = server;
  storage.set('/mru/server', url);
};

const start = (): void => {
  // Create the browser window.
  const window = new BrowserWindow({
    height: 768,
    width: 1024,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });
  // and load the index.html of the app.
  window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // allow the user to press Alt and force display of the server selection
  window.webContents.on('before-input-event', (event, input) => {
    if (input.alt) {
      storage.remove('/mru/server');
      event.preventDefault();
    }
  });

  ipcMain.on(IPC_MESSAGES.START_SERVER_DISCOVERY, () => {
    isDiscovering = true;
  });

  ipcMain.on(IPC_MESSAGES.CONNECT_TO_SERVER, (_event, server: FrontEndHost) =>
    connectToServer(window, server)
  );

  ipcMain.handle(
    IPC_MESSAGES.CONNECTED_SERVER,
    async _event => connectedServer
  );

  discovery.on('response', function ({ answers }) {
    const answer = answers[0];
    if (!answer) return;
    if (answer.name !== SERVICE_NAME) return;
    if (answer.type !== SERVICE_TYPE) return;

    const server: FrontEndHost = JSON.parse(answer.data.toString());
    // the IP is showing as 127.0.0.1 for local servers when running on windows
    server.isLocal = server.ip === ip.address() || server.ip === '127.0.0.1';

    const mruServer = storage.get('/mru/server');
    // if there is a recent server.. and we have found it - no need to display the server selection
    // simply connect to it. Otherwise.. the server should be displayed.
    if (mruServer && mruServer === frontEndHostUrl(server)) {
      connectToServer(window, server);
    } else {
      window.webContents.send(IPC_MESSAGES.SERVER_DISCOVERED, server);
    }
  });

  setInterval(() => {
    if (!isDiscovering) return;

    discovery.query({
      questions: [
        {
          name: SERVICE_NAME,
          type: SERVICE_TYPE,
        },
      ],
    });
  }, QUERY_INTERVAL);
};

app.on('ready', start);

app.on('window-all-closed', () => {
  app.quit();
});

app.on(
  'certificate-error',
  (event, _webContents, url, _error, _certificate, callback) => {
    if (!connectedServer) return callback(false);

    if (url.startsWith(frontEndHostUrl(connectedServer))) {
      event.preventDefault();
      callback(true);
    } else {
      callback(false);
    }
  }
);
